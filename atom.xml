<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HWolf&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hwolf.cn/"/>
  <updated>2018-01-02T11:37:16.000Z</updated>
  <id>http://hwolf.cn/</id>
  
  <author>
    <name>HWolf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker-3 Stacks</title>
    <link href="http://hwolf.cn/2017/12/11/Docker-3%20Stacks/"/>
    <id>http://hwolf.cn/2017/12/11/Docker-3 Stacks/</id>
    <published>2017-12-11T10:57:50.000Z</published>
    <updated>2018-01-02T11:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>还记得吗，之前我们已经使用过了 Stack 来部署我们的App：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy</span><br></pre></td></tr></table></figure><p>还是照常，我们看看官方的定义:</p><blockquote><p>A stack is a group of interrelated services that share dependencies, and can be orchestrated and scaled together.</p></blockquote><p>Stack是一组相互关联的Service，之间可以共享依赖关系，并且可以协调在一起。</p><h2 id="添加一个新的Service"><a href="#添加一个新的Service" class="headerlink" title="添加一个新的Service"></a>添加一个新的Service</h2><p>在之前说，yml配置文件中，services选项可以配置多个，其实就是多个Service可能会相互使用，形成 Stack。接下来往配置文件，增加一个新Service，使我们能在网页上看见node的信息(参数可以翻翻前面的Service讲解)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: username/repo:tag</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          memory: 50M</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  visualizer:</span><br><span class="line">  # Docker 官方提供可视化管理node的镜像</span><br><span class="line">    image: dockersamples/visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    # sock 关联</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      # 运行在swarm manager上，而不是worker，这样才能在整个Stack 运行</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br></pre></td></tr></table></figure><p>这里需要强调一下，确保你编写yml的文件是对你的swarm manager生效，而不是其他node。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有 Container 信息</span><br><span class="line">docker-machine ls</span><br><span class="line"># 对于Mac，如果不是，设置 swarm manager</span><br><span class="line">docker-machine env yourSwarmManagerName</span><br><span class="line">eval $(docker-machine env yourSwarmManagerName)</span><br><span class="line"></span><br><span class="line"># Windows</span><br><span class="line">docker-machine env yourSwarmManagerName</span><br><span class="line">&amp; &quot;C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe&quot; env myvm1 | Invoke-Expression</span><br></pre></td></tr></table></figure><p>生效配置文件，重新部署App，并访问本地8080端口查看结果。当然，我们也可以查看看dockersamples/visualizer:stable 运行状态了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 部署</span><br><span class="line">docker stack deploy -c docker-compose.yml yourServiceName</span><br><span class="line"># 查看当前运行Service</span><br><span class="line">docker stack ps yourServiceName</span><br></pre></td></tr></table></figure><h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>不管哪个App都离不开数据库，在这里我们利用Stack特性，添加Redis服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    # replace username/repo:tag with your name and image details</span><br><span class="line">    image: username/repo:tag</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          memory: 50M</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  visualizer:</span><br><span class="line">    image: dockersamples/visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379:6379&quot;</span><br><span class="line">    volumes:</span><br><span class="line">     # yourSystemDataDir:containerDataDir</span><br><span class="line">     # 如果不映射保存数据，那么一旦重新部署Redis的数据就没了。</span><br><span class="line">      - /home/docker/data:/data</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    command: redis-server --appendonly yes</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;还记得吗，之前我们已经使用过了 Stack 来部署我们的App：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://hwolf.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-2 Service与Swarms</title>
    <link href="http://hwolf.cn/2017/12/10/Docker-2-Service%E4%B8%8ESwarm/"/>
    <id>http://hwolf.cn/2017/12/10/Docker-2-Service与Swarm/</id>
    <published>2017-12-10T12:40:17.000Z</published>
    <updated>2018-01-02T11:05:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>这部分可以通过负载均衡提升 App 效率。前面的 Container 是运行的images+yourRequirements ，那么接下来要介绍的 Service 就是真正 “生产的Container” (“containers in production”) ，因为你的某个 Container 可能就自己在玩自己的，你在这个Container装了Redis,MySQL等等等，然后对外暴露个端口供用户访问，功能是能够实现。但是，此时这种Container就像一个耦合度是不是很高？如果MySQL内的资源是共享的呢？</p><p>而利用Service，我们就能将一个个服务拆分开来，利用统一配置文件来管理各个 Service 即可。再强调一下，本质上Service也是Container。</p><h3 id="docker-compose-yml-文件"><a href="#docker-compose-yml-文件" class="headerlink" title="docker-compose.yml 文件"></a>docker-compose.yml 文件</h3><p>官方介绍</p><blockquote><p>A docker-compose.yml file is a YAML file that defines how Docker containers should behave in production.<br>也就是说 docker-compose.yml 定义了 Service(Container) 的行为/作用。</p></blockquote><p>官方配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  # Service name</span><br><span class="line">  web:</span><br><span class="line">    # replace username/repo:tag with your name and image details</span><br><span class="line">    image: username/repo:tag</span><br><span class="line">    deploy:</span><br><span class="line">      # 可运行实例数，不配置默认为1</span><br><span class="line">      replicas: 5</span><br><span class="line">      # 资源配置</span><br><span class="line">      resources:</span><br><span class="line">        # 最大限制</span><br><span class="line">        limits:</span><br><span class="line">          # cpu 占用率</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          # RAM 大小</span><br><span class="line">          memory: 50M</span><br><span class="line">      # 重启规则,一旦挂了立即重启</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    # 负载均衡配置</span><br><span class="line">    networks:</span><br><span class="line">    # 需要编写 webnet</span><br><span class="line">      - webnet</span><br><span class="line">   </span><br><span class="line">   ...</span><br><span class="line">   ...</span><br><span class="line">   ...</span><br><span class="line"># 自定义负载均衡，不写就是默认（defalut）了</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br></pre></td></tr></table></figure><h3 id="运行APP"><a href="#运行APP" class="headerlink" title="运行APP"></a>运行APP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init</span><br><span class="line"># 生效配置，部署Service</span><br><span class="line">docker stack deploy -c docker-compose.yml yourServiceName</span><br><span class="line"># 列出正在运行的Service,同时又多个实例运行，实例的ID是不一样</span><br><span class="line">docker service ls</span><br><span class="line"># 显示指定 Container(Service) 运行的 task</span><br><span class="line">docker service ps getstartedlab_web</span><br><span class="line"># 显示本机中所有运行的 task</span><br><span class="line">docker container ls -q</span><br><span class="line"># 修改配置后重新运行</span><br><span class="line">docker stack deploy -c docker-compose.yml yourServiceName</span><br><span class="line"># 删除 Service</span><br><span class="line">docker stack rm getstartedlab</span><br><span class="line"># 移除 swarm</span><br><span class="line">docker swarm leave --force</span><br></pre></td></tr></table></figure><p>官方解释对 Service 配置作用的解释</p><blockquote><p>Either way, you’ll see the container ID change, demonstrating the load-balancing; with each request, one of the 5 tasks is chosen, in a round-robin fashion, to respond. The container IDs will match your output from the previous command</p></blockquote><h3 id="命令总结"><a href="#命令总结" class="headerlink" title="命令总结"></a>命令总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker stack ls                                            # List stacks or apps</span><br><span class="line">docker stack deploy -c &lt;composefile&gt; &lt;appname&gt;  # Run the specified Compose file</span><br><span class="line">docker service ls                 # List running services associated with an app</span><br><span class="line">docker service ps &lt;service&gt;                  # List tasks associated with an app</span><br><span class="line">docker inspect &lt;task or container&gt;                   # Inspect task or container</span><br><span class="line">docker container ls -q                                      # List container IDs</span><br><span class="line">docker stack rm &lt;appname&gt;                             # Tear down an application</span><br><span class="line">docker swarm leave --force      # Take down a single node swarm from the manager</span><br></pre></td></tr></table></figure><h2 id="Swarms"><a href="#Swarms" class="headerlink" title="Swarms"></a>Swarms</h2><p><a href="https://docs.docker.com/get-started/part4/#deploy-the-app-on-the-swarm-manager" target="_blank" rel="noopener">https://docs.docker.com/get-started/part4/#deploy-the-app-on-the-swarm-manager</a></p><p>swarm是一群的意思，所以不难看出是为了解决多机部署问题。</p><h3 id="Swarm-定义"><a href="#Swarm-定义" class="headerlink" title="Swarm 定义"></a>Swarm 定义</h3><p>先来看看官方对swarm 的定义</p><blockquote><p>A swarm is a group of machines that are running Docker and joined into a cluster.</p></blockquote><p>当一台机器的时候使用docker的时候我们可能不需要swarm。但当需要部署多台机器、多台虚拟设备，也就是说众多docker 形成集群，此时管理整个集群的主机就可以称为 swarm manager，而其余每个含docker的主机就是节点(node) 。</p><h3 id="swarm-manager"><a href="#swarm-manager" class="headerlink" title="swarm manager"></a>swarm manager</h3><ul><li>唯一可以执行指令</li><li>唯一可以授权新节点（node）加入集群</li></ul><h3 id="Swarm-管理策略"><a href="#Swarm-管理策略" class="headerlink" title="Swarm 管理策略"></a>Swarm 管理策略</h3><p>swarm有几个管理docker的策略：</p><ul><li>emptiest node</li></ul><blockquote><p>which fills the least utilized machines with containers</p></blockquote><ul><li>global</li></ul><blockquote><p>which ensures that each machine gets exactly one instance of the specified container</p></blockquote><p>具体解释如下：</p><p>emptiest node（集中分配）：这种策略是将尽量使用少的主机运行 Container。</p><p>global (平均分配)：确保每个主机都有运行的 Container。</p><h3 id="Swarm-建立"><a href="#Swarm-建立" class="headerlink" title="Swarm 建立"></a>Swarm 建立</h3><p>接下来就是建立集群了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在 swarm manager 中运行</span><br><span class="line">docker swarm init</span><br><span class="line"># 在另一台node 中运行，加入集群</span><br><span class="line">docker swarm join</span><br></pre></td></tr></table></figure><p>接下来的命令你可以在虚拟机中运行，等有需求再更新这部分吧~</p><h3 id="命令总结-1"><a href="#命令总结-1" class="headerlink" title="命令总结"></a>命令总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create --driver virtualbox myvm1 # Create a VM (Mac, Win7, Linux)</span><br><span class="line">docker-machine create -d hyperv --hyperv-virtual-switch &quot;myswitch&quot; myvm1 # Win10</span><br><span class="line">docker-machine env myvm1                # View basic information about your node</span><br><span class="line">docker-machine ssh myvm1 &quot;docker node ls&quot;         # List the nodes in your swarm</span><br><span class="line">docker-machine ssh myvm1 &quot;docker node inspect &lt;node ID&gt;&quot;        # Inspect a node</span><br><span class="line">docker-machine ssh myvm1 &quot;docker swarm join-token -q worker&quot;   # View join token</span><br><span class="line">docker-machine ssh myvm1   # Open an SSH session with the VM; type &quot;exit&quot; to end</span><br><span class="line">docker node ls                # View nodes in swarm (while logged on to manager)</span><br><span class="line">docker-machine ssh myvm2 &quot;docker swarm leave&quot;  # Make the worker leave the swarm</span><br><span class="line">docker-machine ssh myvm1 &quot;docker swarm leave -f&quot; # Make master leave, kill swarm</span><br><span class="line">docker-machine ls # list VMs, asterisk shows which VM this shell is talking to</span><br><span class="line">docker-machine start myvm1            # Start a VM that is currently not running</span><br><span class="line">docker-machine env myvm1      # show environment variables and command for myvm1</span><br><span class="line">eval $(docker-machine env myvm1)         # Mac command to connect shell to myvm1</span><br><span class="line">&amp; &quot;C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe&quot; env myvm1 | Invoke-Expression   # Windows command to connect shell to myvm1</span><br><span class="line">docker stack deploy -c &lt;file&gt; &lt;app&gt;  # Deploy an app; command shell must be set to talk to manager (myvm1), uses local Compose file</span><br><span class="line">docker-machine scp docker-compose.yml myvm1:~ # Copy file to node&apos;s home dir (only required if you use ssh to connect to manager and deploy the app)</span><br><span class="line">docker-machine ssh myvm1 &quot;docker stack deploy -c &lt;file&gt; &lt;app&gt;&quot;   # Deploy an app using ssh (you must have first copied the Compose file to myvm1)</span><br><span class="line">eval $(docker-machine env -u)     # Disconnect shell from VMs, use native docker</span><br><span class="line">docker-machine stop $(docker-machine ls -q)               # Stop all running VMs</span><br><span class="line">docker-machine rm $(docker-machine ls -q) # Delete all VMs and their disk images</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Service&quot;&gt;&lt;a href=&quot;#Service&quot; class=&quot;headerlink&quot; title=&quot;Service&quot;&gt;&lt;/a&gt;Service&lt;/h2&gt;&lt;p&gt;这部分可以通过负载均衡提升 App 效率。前面的 Container 是运行的images+your
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://hwolf.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-1 Dockerfile与Container</title>
    <link href="http://hwolf.cn/2017/12/10/Docker-1-Dockerfile%E4%B8%8EContainer/"/>
    <id>http://hwolf.cn/2017/12/10/Docker-1-Dockerfile与Container/</id>
    <published>2017-12-10T10:29:37.000Z</published>
    <updated>2018-01-02T11:04:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>关于安装Docker这里就不做介绍了，注意如果是个人使用安装ce版，免费的。</p><ol><li>images – 镜像文件</li><li>Container – 可以看做一个运行的虚拟机，但是是进程隔离的。</li><li>Dockerfile – 是用于构建Container的脚本文件</li></ol><p>Docker如同单词的字面意思一样，就像一个码头，你可以把基础的images看作小集装箱，里面有着很多货物（your requirements）。你可以选择直接运行images，这时就变成了Container/Service。此时的Container是一个新的环境，你可以往images里面添加新的货物（requirements）再运行。如果你觉得你这个加了料的还不错，你可以加上自己的tag 制作成新的集装箱（image）分享给别人。</p><p>最小构建下，拉取环境镜像（如：Java image），然后将我们的 App 够建到镜像之内，保证App能在运行时获取所需的dependencies。</p><h2 id="Dockerfile构建-Container"><a href="#Dockerfile构建-Container" class="headerlink" title="Dockerfile构建 Container"></a>Dockerfile构建 Container</h2><p>虽然可以通过拉取基础系统镜像，然后进入镜像中用Linux shell一步步安装、配置各种环境，但这样构建出来的镜像往往会很大，这也是官方建议使用Dockerfile来构建Container的原因之一。</p><p>通常，当我们要启用一个新的Container，会新建一个文件夹，在文件夹内部创建一个新的Dockerfile，以下是来自官方的Demo。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Use an official Python runtime as a parent image</span><br><span class="line"># 必须：FROM 一个所需镜像</span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"># Set the working directory to /app</span><br><span class="line"># Container 的工作目录</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># Copy the current directory contents into the container at /app</span><br><span class="line"># 将当前目录 . 的内容添加到 /app 目录中</span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line"># Install any needed packages specified in requirements.txt</span><br><span class="line"># 安装需要的 packages，特别的 dependecies 可以在requirements.txt 文件中指出</span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"># Make port 80 available to the world outside this container</span><br><span class="line"># TODO</span><br><span class="line"># 必须：暴露Container内的 80 端口（还需要暴露System 端口）</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># Define environment variable</span><br><span class="line"># 定义环境变量</span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"># Run app.py when the container launches</span><br><span class="line"># 容器启动时运行 app.py</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure><p>如果项目需要配置代理服务器（如：nginx），可以根据代理中的配置，在Dockerfile中进行如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Set proxy server, replace host:port with values for your servers</span><br><span class="line">ENV http_proxy host:port</span><br><span class="line">ENV https_proxy host:por</span><br></pre></td></tr></table></figure><p>需要注意的是，在Dockerfile 中配置的文件，如果没有指定路径，都是默认放在与Dockerfile同级的目录下的。在当前目录下编译Dockerfile 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 编译 docker build -t &quot;imageName&quot;</span><br><span class="line">docker build -t friendlyhello .</span><br><span class="line"># 查看本机所含镜像文件</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><p>运行 friendlyhello镜像，暴露Container 80端口，而映射System 4000 端口作为外部访问端口，访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 终端运行</span><br><span class="line">docker run -p 4000:80 friendlyhello</span><br><span class="line"># 后台运行</span><br><span class="line">docker run -d -p 4000:80 friendlyhello</span><br><span class="line"># 查看运行的 Container</span><br><span class="line">docker container ls</span><br></pre></td></tr></table></figure><p>接着，我们分析一下上面那样做的好处吧。假设，系统本身是不含python 环境，以及redis Flask 等，那么是执行不了上面的app.py的吧？那么当docker通过Dockerfile 构建好了环境时，在Container 内就可以运行了app.py文件，但是正如前面所介绍的Container 就像一个虚拟机，此时本机上还是不含python 环境！！这样我们就可以做出很多有意思的事情了，python2,python3,Java8,Java9等App 都能在一台机子上运行。</p><p>这是官方总结一些常用的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker build -t friendlyname .  # Create image using this directory&apos;s Dockerfile</span><br><span class="line">docker run -p 4000:80 friendlyname  # Run &quot;friendlyname&quot; mapping port 4000 to 80</span><br><span class="line">docker run -d -p 4000:80 friendlyname         # Same thing, but in detached mode</span><br><span class="line">docker container ls                                # List all running containers</span><br><span class="line">docker container ls -a             # List all containers, even those not running</span><br><span class="line">docker container stop &lt;hash&gt;           # Gracefully stop the specified container</span><br><span class="line">docker container kill &lt;hash&gt;         # Force shutdown of the specified container</span><br><span class="line">docker container rm &lt;hash&gt;        # Remove specified container from this machine</span><br><span class="line">docker container rm $(docker container ls -a -q)         # Remove all containers</span><br><span class="line">docker image ls -a                             # List all images on this machine</span><br><span class="line">docker image rm &lt;image id&gt;            # Remove specified image from this machine</span><br><span class="line">docker image rm $(docker image ls -a -q)   # Remove all images from this machine</span><br><span class="line">docker login             # Log in this CLI session using your Docker credentials</span><br><span class="line">docker tag &lt;image&gt; username/repository:tag  # Tag &lt;image&gt; for upload to registry</span><br><span class="line">docker push username/repository:tag            # Upload tagged image to registry</span><br><span class="line">docker run username/repository:tag                   # Run image from a registry</span><br></pre></td></tr></table></figure><h2 id="制作image"><a href="#制作image" class="headerlink" title="制作image"></a>制作image</h2><p>接下来主要介绍如何制作一个自己的镜像。</p><h3 id="image的Tag"><a href="#image的Tag" class="headerlink" title="image的Tag"></a>image的Tag</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># docker tag image username/repository:tag</span><br><span class="line">docker tag project-name username/get-started:part2</span><br><span class="line"># docker push</span><br><span class="line">docker push username/repository:tag</span><br><span class="line"># 此时我们就可以通过 username/repository:tag 运行了</span><br><span class="line">docker run -p 4000:80 username/repository:tag</span><br></pre></td></tr></table></figure><p>同时，如果觉得自己做的镜像不错，那么可以分享到Docker Cloud，阿里云，腾讯云等，这里就不进行详细介绍了。</p><blockquote><p>Docker Cloud <a href="https://cloud.docker.com/" target="_blank" rel="noopener">https://cloud.docker.com/</a></p></blockquote><h2 id="Docker-入门推荐阅读"><a href="#Docker-入门推荐阅读" class="headerlink" title="Docker 入门推荐阅读"></a>Docker 入门推荐阅读</h2><blockquote><p>《Docker入门级简易手册》在线版：<a href="https://github.com/buxiaomo/MarkdownBooks" target="_blank" rel="noopener">https://github.com/buxiaomo/MarkdownBooks</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;关于安装Docker这里就不做介绍了，注意如果是个人使用安装ce版，免费的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;images – 镜像文件&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://hwolf.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Java8小结</title>
    <link href="http://hwolf.cn/2017/07/30/Java8%E5%B0%8F%E7%BB%93/"/>
    <id>http://hwolf.cn/2017/07/30/Java8小结/</id>
    <published>2017-07-30T07:43:26.000Z</published>
    <updated>2017-11-30T07:43:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lambda表达式和函数式接口"><a href="#Lambda表达式和函数式接口" class="headerlink" title="Lambda表达式和函数式接口"></a>Lambda表达式和函数式接口</h2><p>它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理</p><h2 id="接口的默认方法和静态方法"><a href="#接口的默认方法和静态方法" class="headerlink" title="接口的默认方法和静态方法"></a>接口的默认方法和静态方法</h2><p>往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法</p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><ol><li>构造器引用</li><li>静态方法引用</li><li>某个类的成员方法的引用</li><li>某个实例对象的成员方法的引</li></ol><h2 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h2><p>使用@Repeatable注解定义重复注解</p><h2 id="注解功能的拓展"><a href="#注解功能的拓展" class="headerlink" title="注解功能的拓展"></a>注解功能的拓展</h2><p>注解几乎可以使用在任何元素上：局部变量、接口类型、超类和接口实现类，甚至可以用在函数的异常定义上</p><h1 id="Java编译器的新特性"><a href="#Java编译器的新特性" class="headerlink" title="Java编译器的新特性"></a>Java编译器的新特性</h1><h2 id="获取参数名称"><a href="#获取参数名称" class="headerlink" title="获取参数名称"></a>获取参数名称</h2><p>在语言层面（使用反射API和Parameter.getName()方法）和字节码层面（使用新的javac编译器以及-parameters参数）提供支持。</p><p>如果你使用Maven进行项目管理，则可以在maven-compiler-plugin编译器的配置项中配置-parameters参数</p><h1 id="Java官方库的新特性"><a href="#Java官方库的新特性" class="headerlink" title="Java官方库的新特性"></a>Java官方库的新特性</h1><p>Java 8增加了很多新的工具类（date/time类），并扩展了现存的工具类，以支持现代的并发编程、函数式编程等。</p><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>Optional仅仅是一个容易：存放T类型的值或者null。</p><p>如果Optional实例持有一个非空值，则isPresent()方法返回true，否则返回false；orElseGet()方法，Optional实例持有null，则可以接受一个lambda表达式生成的默认值；map()方法可以将现有的Opetional实例的值转换成新的值；orElse()方法与orElseGet()方法类似，但是在持有null的时候返回传入的默认值。</p><h2 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h2><p>中间操作：例如filter）并不会执行实际的过滤操作，而是创建一个新的steam，并将原steam中符合条件的元素放入新创建的steam。</p><p>晚期操作：会遍历steam并得出结果或者附带结果；在执行晚期操作之后，steam处理线已经处理完毕，就不能使用了</p><p>支持并行处理</p><h2 id="Date-Time-API-JSR-310"><a href="#Date-Time-API-JSR-310" class="headerlink" title="Date/Time API(JSR 310)"></a>Date/Time API(JSR 310)</h2><p>Clock可以替代System.currentTimeMillis()和TimeZone.getDefault()<br>LocalDate和LocalTime<br>特定时区的data/time信息，则可以使用ZoneDateTime<br>Duration类，它持有的时间精确到秒和纳秒。这使得我们可以很容易得计算两个日期之间的不同</p><h2 id="并行数组"><a href="#并行数组" class="headerlink" title="并行数组"></a>并行数组</h2><h2 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h2><p>在java.util.concurrent.atomic包中也新增了不少工具类，列举如下：</p><ul><li>DoubleAccumulator</li><li>DoubleAdder</li><li>LongAccumulator</li><li>LongAdder</li></ul><p>java.util.concurrent.locks.StampedLock类，用于支持基于容量的锁——该锁有三个模型用于支持读写操作</p><h1 id="JVM特性"><a href="#JVM特性" class="headerlink" title="JVM特性"></a>JVM特性</h1><p>-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Lambda表达式和函数式接口&quot;&gt;&lt;a href=&quot;#Lambda表达式和函数式接口&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式和函数式接口&quot;&gt;&lt;/a&gt;Lambda表达式和函数式接口&lt;/h2&gt;&lt;p&gt;它允许我们将函数当成参数传递给某个方
      
    
    </summary>
    
    
  </entry>
  
</feed>
