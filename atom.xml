<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HWolf&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hwolf.cn/"/>
  <updated>2018-01-09T12:42:55.000Z</updated>
  <id>http://hwolf.cn/</id>
  
  <author>
    <name>HWolf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ABOUT ME</title>
    <link href="http://hwolf.cn/2018/01/09/ABOUT%20ME/"/>
    <id>http://hwolf.cn/2018/01/09/ABOUT ME/</id>
    <published>2018-01-09T12:42:30.000Z</published>
    <updated>2018-01-09T12:42:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul><li>黄文锋/男/1996 </li><li>大三/NEUQ通信工程专业 </li><li>Github：<a href="http://github.com/HWOLFeng" target="_blank" rel="noopener">http://github.com/HWOLFeng</a> </li><li>期望职位：JAVA开发工程师，架构师</li><li>期望城市：北京<h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><ul><li>Email：wolf2295566872@gmail.com </li><li>QQ：2295566872</li></ul></li></ul><h1 id="实习经历"><a href="#实习经历" class="headerlink" title="实习经历"></a>实习经历</h1><h2 id="某初创公司-（-2017年9月-至今）"><a href="#某初创公司-（-2017年9月-至今）" class="headerlink" title="某初创公司 （ 2017年9月 ~ 至今）"></a>某初创公司 （ 2017年9月 ~ 至今）</h2><h3 id="无源智能锁后台管理系统"><a href="#无源智能锁后台管理系统" class="headerlink" title="无源智能锁后台管理系统"></a>无源智能锁后台管理系统</h3><p>我在此项目负责设计数据库表、接口，以及技术实现、测试、优化，最终部署、维护，从立项到最后交付历时两周。本项目基于SSM框架，实现前后端分离，增加Shiro进行权限控制，自动化部署使用Gitlab+Jenkins。</p><h1 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h1><p>以下均为我掌握的技能</p><ul><li>Web开发：JAVA</li><li>Web框架：Spring/SpringMVC/Spring Boot/Mybatis/Dubbo</li><li>数据库相关：MySQL/Redis</li><li>版本管理和自动化部署工具：Git/Docker/Jenkins</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;个人信息&quot;&gt;&lt;a href=&quot;#个人信息&quot; class=&quot;headerlink&quot; title=&quot;个人信息&quot;&gt;&lt;/a&gt;个人信息&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;黄文锋/男/1996 &lt;/li&gt;
&lt;li&gt;大三/NEUQ通信工程专业 &lt;/li&gt;
&lt;li&gt;Github：&lt;a h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL总结</title>
    <link href="http://hwolf.cn/2018/01/01/MySQL%E6%80%BB%E7%BB%93/"/>
    <id>http://hwolf.cn/2018/01/01/MySQL总结/</id>
    <published>2018-01-01T11:02:08.000Z</published>
    <updated>2018-01-09T10:25:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>新年第一篇！！</p><p>虽然现在都可以用可视化的管理工具远程连接、管理数据库了，但是有时候还是有很多情况需要用到Terminal手打SQL的，要准备实习了，通过本篇笔记也算是对自己SQL学习的一个总结吧。</p><p>说明：数据库中的关键词都用大写，数据库中一般都用<code>_</code>，当然，命名如果有不符合规范的地方，请指正~</p><h1 id="初阶SQL"><a href="#初阶SQL" class="headerlink" title="初阶SQL"></a>初阶SQL</h1><h2 id="库操作"><a href="#库操作" class="headerlink" title="库操作"></a>库操作</h2><h3 id="创建数据库、表"><a href="#创建数据库、表" class="headerlink" title="创建数据库、表"></a>创建数据库、表</h3><p>初学的时候用原生，现在都是使用可视化工具操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 创建数据库</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> database_name;</span><br><span class="line"># 带utf8</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> database_name <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci;</span><br><span class="line"># 创建表，一些特殊的字段</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">BIGINT</span> AUTO_INCREMENT</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">  <span class="string">`key_value`</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'key_value'</span>,</span><br><span class="line">  <span class="keyword">status</span> TINYINT  <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'状态 0：隐藏 1：显示'</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`key_value`</span></span><br><span class="line">  <span class="keyword">UNIQUE</span> (key_value)</span><br><span class="line">)</span><br><span class="line">  <span class="keyword">comment</span> <span class="string">'表名'</span>;</span><br></pre></td></tr></table></figure><h3 id="删除数据库、表"><a href="#删除数据库、表" class="headerlink" title="删除数据库、表"></a>删除数据库、表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 数据库</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> database_name;</span><br><span class="line"># 表</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure><h3 id="修改已有表"><a href="#修改已有表" class="headerlink" title="修改已有表"></a>修改已有表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 插入新列，约束：和创建表时的一样</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">col</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>);</span><br><span class="line"># 添加主列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tabname <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span>(<span class="keyword">col</span>);</span><br><span class="line"># 删除主列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span>(<span class="keyword">col</span>);</span><br></pre></td></tr></table></figure><h3 id="查看数据库、表"><a href="#查看数据库、表" class="headerlink" title="查看数据库、表"></a>查看数据库、表</h3><p>终端中一般不打大写。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前用户下的数据库</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"># 查看当前数据库</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">database</span>();</span><br><span class="line"># 切换数据库</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">database</span>-<span class="keyword">name</span>;</span><br><span class="line"># 查看当前数据库表</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><h3 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h3><p>先来说说WHERE条件的限制：</p><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">=、&lt;、&lt;=、&gt;、&gt;=</td><td style="text-align:center">等于、小于、小于等于、大于、大于等于</td></tr><tr><td style="text-align:center">&lt;&gt;</td><td style="text-align:center">不等于</td></tr><tr><td style="text-align:center">BETWEEN</td><td style="text-align:center">某个范围内</td></tr><tr><td style="text-align:center">LIKE</td><td style="text-align:center">含有某个值（可传入正则表达式）</td></tr></tbody></table><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (col1,col2,col3) <span class="keyword">VALUES</span> (val1,val2,val3);</span><br></pre></td></tr></table></figure><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> <span class="keyword">col</span>=val <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 选一行</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ...</span><br><span class="line"># 选指定列</span><br><span class="line"><span class="keyword">SELECT</span> (col1,col2...) <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ...</span><br><span class="line"># 查看指定列不同的值</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">col</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"># 查看不同元素</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> * <span class="keyword">FROM</span> table_name</span><br><span class="line"># 查看元素数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> table_name</span><br><span class="line"># 查看指定列的有效元素数(<span class="literal">NULL</span> 不计入)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">col</span>) <span class="keyword">FROM</span> table_name</span><br><span class="line"># 查看满足多个条件的行</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> <span class="keyword">IN</span> (val1,val2,...)</span><br><span class="line"># 使用别名查看</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">AS</span> alias_name</span><br></pre></td></tr></table></figure><h1 id="中阶SQL"><a href="#中阶SQL" class="headerlink" title="中阶SQL"></a>中阶SQL</h1><p>这部分主要是列出一些比较常用，但是需要理解的SQL。</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查询规定要返回的记录的数目number</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="built_in">number</span></span><br></pre></td></tr></table></figure><h3 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h3><blockquote><p>SQL join 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。</p></blockquote><p>先说明几个概念：</p><ul><li>INNER JOIN: 如果表中有至少一个匹配，则返回行</li><li>LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行</li><li>RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行</li><li>FULL JOIN: 全连接，只要其中一个表中存在匹配，就返回行(MySQL中没有，不举例了)</li></ul><p>这是本次使用到的两张表，assets和user：<br><img src="/image/assets.png" alt="assets-table"><br><img src="/image/user.png" alt="user-table"></p><h4 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> table_name2 </span><br><span class="line"><span class="keyword">ON</span> table_name1.col=table_name2.col</span><br></pre></td></tr></table></figure><p>结果<br><img src="/image/inner-join1.png" alt="inner-join"></p><h4 id="LEFT-JOIN-和-RIGHT-JOIN"><a href="#LEFT-JOIN-和-RIGHT-JOIN" class="headerlink" title="LEFT JOIN 和 RIGHT JOIN"></a>LEFT JOIN 和 RIGHT JOIN</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># LEFT JOIN</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table_name2 </span><br><span class="line"><span class="keyword">ON</span> table_name1.col=table_name2.col</span><br><span class="line"></span><br><span class="line"># <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name1</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table_name2 </span><br><span class="line"><span class="keyword">ON</span> table_name1.col=table_name2.col</span><br></pre></td></tr></table></figure><p>分别是left join和right join的结果<br><img src="/image/left-join.png" alt="left-join"><br><img src="/image/right-join.png" alt="right-join"></p><h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><p>UNION 命令只会选取不同的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>  <span class="keyword">FROM</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">select</span> id_u <span class="keyword">FROM</span> assets;</span><br></pre></td></tr></table></figure><p>UNION ALL 命令会列出所有的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>  <span class="keyword">FROM</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">UNION</span> ALL</span><br><span class="line"><span class="keyword">select</span> id_u <span class="keyword">FROM</span> assets;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p>1.<a href="http://www.w3school.com.cn/sql/index.asp" target="_blank" rel="noopener">W3school-SQL教程</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;新年第一篇！！&lt;/p&gt;
&lt;p&gt;虽然现在都可以用可视化的管理工具远程连接、管理数据库了，但是有时候还是有很多情况需要用到Terminal手打SQL的，要准备实习了，通过本篇笔记也算是对自己SQL学习的一个总结吧。&lt;/p&gt;
&lt;p&gt;说明：数据库中的关键词都用大写，数据库中一般都用
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://hwolf.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Docker-3 Stacks</title>
    <link href="http://hwolf.cn/2017/12/11/Docker-3%20Stacks/"/>
    <id>http://hwolf.cn/2017/12/11/Docker-3 Stacks/</id>
    <published>2017-12-11T10:57:50.000Z</published>
    <updated>2018-01-02T11:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>还记得吗，之前我们已经使用过了 Stack 来部署我们的App：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy</span><br></pre></td></tr></table></figure><p>还是照常，我们看看官方的定义:</p><blockquote><p>A stack is a group of interrelated services that share dependencies, and can be orchestrated and scaled together.</p></blockquote><p>Stack是一组相互关联的Service，之间可以共享依赖关系，并且可以协调在一起。</p><h2 id="添加一个新的Service"><a href="#添加一个新的Service" class="headerlink" title="添加一个新的Service"></a>添加一个新的Service</h2><p>在之前说，yml配置文件中，services选项可以配置多个，其实就是多个Service可能会相互使用，形成 Stack。接下来往配置文件，增加一个新Service，使我们能在网页上看见node的信息(参数可以翻翻前面的Service讲解)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: username/repo:tag</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          memory: 50M</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  visualizer:</span><br><span class="line">  # Docker 官方提供可视化管理node的镜像</span><br><span class="line">    image: dockersamples/visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    # sock 关联</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      # 运行在swarm manager上，而不是worker，这样才能在整个Stack 运行</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br></pre></td></tr></table></figure><p>这里需要强调一下，确保你编写yml的文件是对你的swarm manager生效，而不是其他node。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有 Container 信息</span><br><span class="line">docker-machine ls</span><br><span class="line"># 对于Mac，如果不是，设置 swarm manager</span><br><span class="line">docker-machine env yourSwarmManagerName</span><br><span class="line">eval $(docker-machine env yourSwarmManagerName)</span><br><span class="line"></span><br><span class="line"># Windows</span><br><span class="line">docker-machine env yourSwarmManagerName</span><br><span class="line">&amp; &quot;C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe&quot; env myvm1 | Invoke-Expression</span><br></pre></td></tr></table></figure><p>生效配置文件，重新部署App，并访问本地8080端口查看结果。当然，我们也可以查看看dockersamples/visualizer:stable 运行状态了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 部署</span><br><span class="line">docker stack deploy -c docker-compose.yml yourServiceName</span><br><span class="line"># 查看当前运行Service</span><br><span class="line">docker stack ps yourServiceName</span><br></pre></td></tr></table></figure><h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>不管哪个App都离不开数据库，在这里我们利用Stack特性，添加Redis服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    # replace username/repo:tag with your name and image details</span><br><span class="line">    image: username/repo:tag</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          memory: 50M</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  visualizer:</span><br><span class="line">    image: dockersamples/visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379:6379&quot;</span><br><span class="line">    volumes:</span><br><span class="line">     # yourSystemDataDir:containerDataDir</span><br><span class="line">     # 如果不映射保存数据，那么一旦重新部署Redis的数据就没了。</span><br><span class="line">      - /home/docker/data:/data</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    command: redis-server --appendonly yes</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;还记得吗，之前我们已经使用过了 Stack 来部署我们的App：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://hwolf.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-2 Service与Swarms</title>
    <link href="http://hwolf.cn/2017/12/10/Docker-2-Service%E4%B8%8ESwarm/"/>
    <id>http://hwolf.cn/2017/12/10/Docker-2-Service与Swarm/</id>
    <published>2017-12-10T12:40:17.000Z</published>
    <updated>2018-01-02T11:05:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>这部分可以通过负载均衡提升 App 效率。前面的 Container 是运行的images+yourRequirements ，那么接下来要介绍的 Service 就是真正 “生产的Container” (“containers in production”) ，因为你的某个 Container 可能就自己在玩自己的，你在这个Container装了Redis,MySQL等等等，然后对外暴露个端口供用户访问，功能是能够实现。但是，此时这种Container就像一个耦合度是不是很高？如果MySQL内的资源是共享的呢？</p><p>而利用Service，我们就能将一个个服务拆分开来，利用统一配置文件来管理各个 Service 即可。再强调一下，本质上Service也是Container。</p><h3 id="docker-compose-yml-文件"><a href="#docker-compose-yml-文件" class="headerlink" title="docker-compose.yml 文件"></a>docker-compose.yml 文件</h3><p>官方介绍</p><blockquote><p>A docker-compose.yml file is a YAML file that defines how Docker containers should behave in production.<br>也就是说 docker-compose.yml 定义了 Service(Container) 的行为/作用。</p></blockquote><p>官方配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  # Service name</span><br><span class="line">  web:</span><br><span class="line">    # replace username/repo:tag with your name and image details</span><br><span class="line">    image: username/repo:tag</span><br><span class="line">    deploy:</span><br><span class="line">      # 可运行实例数，不配置默认为1</span><br><span class="line">      replicas: 5</span><br><span class="line">      # 资源配置</span><br><span class="line">      resources:</span><br><span class="line">        # 最大限制</span><br><span class="line">        limits:</span><br><span class="line">          # cpu 占用率</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          # RAM 大小</span><br><span class="line">          memory: 50M</span><br><span class="line">      # 重启规则,一旦挂了立即重启</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    # 负载均衡配置</span><br><span class="line">    networks:</span><br><span class="line">    # 需要编写 webnet</span><br><span class="line">      - webnet</span><br><span class="line">   </span><br><span class="line">   ...</span><br><span class="line">   ...</span><br><span class="line">   ...</span><br><span class="line"># 自定义负载均衡，不写就是默认（defalut）了</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br></pre></td></tr></table></figure><h3 id="运行APP"><a href="#运行APP" class="headerlink" title="运行APP"></a>运行APP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init</span><br><span class="line"># 生效配置，部署Service</span><br><span class="line">docker stack deploy -c docker-compose.yml yourServiceName</span><br><span class="line"># 列出正在运行的Service,同时又多个实例运行，实例的ID是不一样</span><br><span class="line">docker service ls</span><br><span class="line"># 显示指定 Container(Service) 运行的 task</span><br><span class="line">docker service ps getstartedlab_web</span><br><span class="line"># 显示本机中所有运行的 task</span><br><span class="line">docker container ls -q</span><br><span class="line"># 修改配置后重新运行</span><br><span class="line">docker stack deploy -c docker-compose.yml yourServiceName</span><br><span class="line"># 删除 Service</span><br><span class="line">docker stack rm getstartedlab</span><br><span class="line"># 移除 swarm</span><br><span class="line">docker swarm leave --force</span><br></pre></td></tr></table></figure><p>官方解释对 Service 配置作用的解释</p><blockquote><p>Either way, you’ll see the container ID change, demonstrating the load-balancing; with each request, one of the 5 tasks is chosen, in a round-robin fashion, to respond. The container IDs will match your output from the previous command</p></blockquote><h3 id="命令总结"><a href="#命令总结" class="headerlink" title="命令总结"></a>命令总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker stack ls                                            # List stacks or apps</span><br><span class="line">docker stack deploy -c &lt;composefile&gt; &lt;appname&gt;  # Run the specified Compose file</span><br><span class="line">docker service ls                 # List running services associated with an app</span><br><span class="line">docker service ps &lt;service&gt;                  # List tasks associated with an app</span><br><span class="line">docker inspect &lt;task or container&gt;                   # Inspect task or container</span><br><span class="line">docker container ls -q                                      # List container IDs</span><br><span class="line">docker stack rm &lt;appname&gt;                             # Tear down an application</span><br><span class="line">docker swarm leave --force      # Take down a single node swarm from the manager</span><br></pre></td></tr></table></figure><h2 id="Swarms"><a href="#Swarms" class="headerlink" title="Swarms"></a>Swarms</h2><p><a href="https://docs.docker.com/get-started/part4/#deploy-the-app-on-the-swarm-manager" target="_blank" rel="noopener">https://docs.docker.com/get-started/part4/#deploy-the-app-on-the-swarm-manager</a></p><p>swarm是一群的意思，所以不难看出是为了解决多机部署问题。</p><h3 id="Swarm-定义"><a href="#Swarm-定义" class="headerlink" title="Swarm 定义"></a>Swarm 定义</h3><p>先来看看官方对swarm 的定义</p><blockquote><p>A swarm is a group of machines that are running Docker and joined into a cluster.</p></blockquote><p>当一台机器的时候使用docker的时候我们可能不需要swarm。但当需要部署多台机器、多台虚拟设备，也就是说众多docker 形成集群，此时管理整个集群的主机就可以称为 swarm manager，而其余每个含docker的主机就是节点(node) 。</p><h3 id="swarm-manager"><a href="#swarm-manager" class="headerlink" title="swarm manager"></a>swarm manager</h3><ul><li>唯一可以执行指令</li><li>唯一可以授权新节点（node）加入集群</li></ul><h3 id="Swarm-管理策略"><a href="#Swarm-管理策略" class="headerlink" title="Swarm 管理策略"></a>Swarm 管理策略</h3><p>swarm有几个管理docker的策略：</p><ul><li>emptiest node</li></ul><blockquote><p>which fills the least utilized machines with containers</p></blockquote><ul><li>global</li></ul><blockquote><p>which ensures that each machine gets exactly one instance of the specified container</p></blockquote><p>具体解释如下：</p><p>emptiest node（集中分配）：这种策略是将尽量使用少的主机运行 Container。</p><p>global (平均分配)：确保每个主机都有运行的 Container。</p><h3 id="Swarm-建立"><a href="#Swarm-建立" class="headerlink" title="Swarm 建立"></a>Swarm 建立</h3><p>接下来就是建立集群了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在 swarm manager 中运行</span><br><span class="line">docker swarm init</span><br><span class="line"># 在另一台node 中运行，加入集群</span><br><span class="line">docker swarm join</span><br></pre></td></tr></table></figure><p>接下来的命令你可以在虚拟机中运行，等有需求再更新这部分吧~</p><h3 id="命令总结-1"><a href="#命令总结-1" class="headerlink" title="命令总结"></a>命令总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create --driver virtualbox myvm1 # Create a VM (Mac, Win7, Linux)</span><br><span class="line">docker-machine create -d hyperv --hyperv-virtual-switch &quot;myswitch&quot; myvm1 # Win10</span><br><span class="line">docker-machine env myvm1                # View basic information about your node</span><br><span class="line">docker-machine ssh myvm1 &quot;docker node ls&quot;         # List the nodes in your swarm</span><br><span class="line">docker-machine ssh myvm1 &quot;docker node inspect &lt;node ID&gt;&quot;        # Inspect a node</span><br><span class="line">docker-machine ssh myvm1 &quot;docker swarm join-token -q worker&quot;   # View join token</span><br><span class="line">docker-machine ssh myvm1   # Open an SSH session with the VM; type &quot;exit&quot; to end</span><br><span class="line">docker node ls                # View nodes in swarm (while logged on to manager)</span><br><span class="line">docker-machine ssh myvm2 &quot;docker swarm leave&quot;  # Make the worker leave the swarm</span><br><span class="line">docker-machine ssh myvm1 &quot;docker swarm leave -f&quot; # Make master leave, kill swarm</span><br><span class="line">docker-machine ls # list VMs, asterisk shows which VM this shell is talking to</span><br><span class="line">docker-machine start myvm1            # Start a VM that is currently not running</span><br><span class="line">docker-machine env myvm1      # show environment variables and command for myvm1</span><br><span class="line">eval $(docker-machine env myvm1)         # Mac command to connect shell to myvm1</span><br><span class="line">&amp; &quot;C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe&quot; env myvm1 | Invoke-Expression   # Windows command to connect shell to myvm1</span><br><span class="line">docker stack deploy -c &lt;file&gt; &lt;app&gt;  # Deploy an app; command shell must be set to talk to manager (myvm1), uses local Compose file</span><br><span class="line">docker-machine scp docker-compose.yml myvm1:~ # Copy file to node&apos;s home dir (only required if you use ssh to connect to manager and deploy the app)</span><br><span class="line">docker-machine ssh myvm1 &quot;docker stack deploy -c &lt;file&gt; &lt;app&gt;&quot;   # Deploy an app using ssh (you must have first copied the Compose file to myvm1)</span><br><span class="line">eval $(docker-machine env -u)     # Disconnect shell from VMs, use native docker</span><br><span class="line">docker-machine stop $(docker-machine ls -q)               # Stop all running VMs</span><br><span class="line">docker-machine rm $(docker-machine ls -q) # Delete all VMs and their disk images</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Service&quot;&gt;&lt;a href=&quot;#Service&quot; class=&quot;headerlink&quot; title=&quot;Service&quot;&gt;&lt;/a&gt;Service&lt;/h2&gt;&lt;p&gt;这部分可以通过负载均衡提升 App 效率。前面的 Container 是运行的images+your
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://hwolf.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-1 Dockerfile与Container</title>
    <link href="http://hwolf.cn/2017/12/10/Docker-1-Dockerfile%E4%B8%8EContainer/"/>
    <id>http://hwolf.cn/2017/12/10/Docker-1-Dockerfile与Container/</id>
    <published>2017-12-10T10:29:37.000Z</published>
    <updated>2018-01-02T16:39:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>关于安装Docker这里就不做介绍了，注意如果是个人使用安装ce版，免费的。</p><ol><li>images – 镜像文件</li><li>Container – 可以看做一个运行的虚拟机，但是是进程隔离的。</li><li>Dockerfile – 是用于构建Container的脚本文件</li></ol><p>Docker如同单词的字面意思一样，就像一个码头，你可以把基础的images看作小集装箱，里面有着很多货物（your requirements）。你可以选择直接运行images，这时就变成了Container/Service。此时的Container是一个新的环境，你可以往images里面添加新的货物（requirements）再运行。如果你觉得你这个加了料的还不错，你可以加上自己的tag 制作成新的集装箱（image）分享给别人。</p><p>最小构建下，拉取环境镜像（如：Java image），然后将我们的 App 够建到镜像之内，保证App能在运行时获取所需的dependencies。</p><h2 id="Dockerfile构建-Container"><a href="#Dockerfile构建-Container" class="headerlink" title="Dockerfile构建 Container"></a>Dockerfile构建 Container</h2><p>虽然可以通过拉取基础系统镜像，然后进入镜像中用Linux shell一步步安装、配置各种环境，然后使用<code>docker commit</code>,但这样构建出来的镜像往往会很大，这也是官方建议使用Dockerfile来构建Container的原因之一。</p><p>通常，当我们要启用一个新的Container，会新建一个文件夹，在文件夹内部创建一个新的Dockerfile，以下是来自官方的Demo。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Use an official Python runtime as a parent image</span><br><span class="line"># 必须：FROM 一个所需镜像</span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"># Set the working directory to /app</span><br><span class="line"># Container 的工作目录</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># Copy the current directory contents into the container at /app</span><br><span class="line"># 将当前目录 . 的内容添加到 /app 目录中</span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line"># Install any needed packages specified in requirements.txt</span><br><span class="line"># 安装需要的 packages，特别的 dependecies 可以在requirements.txt 文件中指出</span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"># Make port 80 available to the world outside this container</span><br><span class="line"># TODO</span><br><span class="line"># 必须：暴露Container内的 80 端口（还需要暴露System 端口）</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># Define environment variable</span><br><span class="line"># 定义环境变量</span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"># Run app.py when the container launches</span><br><span class="line"># 容器启动时运行 app.py</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure><p>如果项目需要配置代理服务器（如：nginx），可以根据代理中的配置，在Dockerfile中进行如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Set proxy server, replace host:port with values for your servers</span><br><span class="line">ENV http_proxy host:port</span><br><span class="line">ENV https_proxy host:por</span><br></pre></td></tr></table></figure><p>需要注意的是，在Dockerfile 中配置的文件，如果没有指定路径，都是默认放在与Dockerfile同级的目录下的。在当前目录下编译Dockerfile 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 编译 docker build -t &quot;imageName&quot;</span><br><span class="line">docker build -t friendlyhello .</span><br><span class="line"># 查看本机所含镜像文件</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><p>运行 friendlyhello镜像，暴露Container 80端口，而映射System 4000 端口作为外部访问端口，访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 终端运行</span><br><span class="line">docker run -p 4000:80 friendlyhello</span><br><span class="line"># 后台运行</span><br><span class="line">docker run -d -p 4000:80 friendlyhello</span><br><span class="line"># 查看运行的 Container</span><br><span class="line">docker container ls</span><br></pre></td></tr></table></figure><p>接着，我们分析一下上面那样做的好处吧。假设，系统本身是不含python 环境，以及redis Flask 等，那么是执行不了上面的app.py的吧？那么当docker通过Dockerfile 构建好了环境时，在Container 内就可以运行了app.py文件，但是正如前面所介绍的Container 就像一个虚拟机，此时本机上还是不含python 环境！！这样我们就可以做出很多有意思的事情了，python2,python3,Java8,Java9等App 都能在一台机子上运行。</p><p>这是官方总结一些常用的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker build -t friendlyname .  # Create image using this directory&apos;s Dockerfile</span><br><span class="line">docker run -p 4000:80 friendlyname  # Run &quot;friendlyname&quot; mapping port 4000 to 80</span><br><span class="line">docker run -d -p 4000:80 friendlyname         # Same thing, but in detached mode</span><br><span class="line">docker container ls                                # List all running containers</span><br><span class="line">docker container ls -a             # List all containers, even those not running</span><br><span class="line">docker container stop &lt;hash&gt;           # Gracefully stop the specified container</span><br><span class="line">docker container kill &lt;hash&gt;         # Force shutdown of the specified container</span><br><span class="line">docker container rm &lt;hash&gt;        # Remove specified container from this machine</span><br><span class="line">docker container rm $(docker container ls -a -q)         # Remove all containers</span><br><span class="line">docker image ls -a                             # List all images on this machine</span><br><span class="line">docker image rm &lt;image id&gt;            # Remove specified image from this machine</span><br><span class="line">docker image rm $(docker image ls -a -q)   # Remove all images from this machine</span><br><span class="line">docker login             # Log in this CLI session using your Docker credentials</span><br><span class="line">docker tag &lt;image&gt; username/repository:tag  # Tag &lt;image&gt; for upload to registry</span><br><span class="line">docker push username/repository:tag            # Upload tagged image to registry</span><br><span class="line">docker run username/repository:tag                   # Run image from a registry</span><br></pre></td></tr></table></figure><h2 id="Dockerfile命令"><a href="#Dockerfile命令" class="headerlink" title="Dockerfile命令"></a>Dockerfile命令</h2><p>接下来说说我对Docker中一些常用的命令的理解，具体的最佳实践还没摸索出来，等以后有机会更新一些demo，当然，有时间可以参考文末的链接。</p><ul><li><code>FROM</code> 指定基础镜像，可以看做package，可以去Dockerhub中找；</li><li><code>RUN</code> 里面写的语句就像shell，但是有点区别，；</li><li><code>EXPOSE</code> 暴露容器端口；</li><li><code>CMD</code> 启动时要运行的命令；</li><li><code>ENV</code> 设置环境变量，构建时和容器内都可以使用；</li><li><code>ADD</code> 复制命令，把本机/URL的文件复制到镜像中；</li><li><code>MAINTAINER</code> 作者信息；</li><li><code>VOLUME</code> 设置卷，一般用于data储存；</li><li><code>WORKDIR</code> 指定容器中的工作目录，有点像shell的cd命令；</li><li><code>USER</code> 指定容器中进程的运行用户是谁、</li></ul><h2 id="制作image"><a href="#制作image" class="headerlink" title="制作image"></a>制作image</h2><p>完成了Dockerfile的编写，接下来主要介绍如何制作一个自己的镜像。</p><h3 id="image的Tag"><a href="#image的Tag" class="headerlink" title="image的Tag"></a>image的Tag</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># docker tag image username/repository:tag</span><br><span class="line">docker tag project-name username/get-started:part2</span><br><span class="line"># docker push</span><br><span class="line">docker push username/repository:tag</span><br><span class="line"># 此时我们就可以通过 username/repository:tag 运行了</span><br><span class="line">docker run -p 4000:80 username/repository:tag</span><br></pre></td></tr></table></figure><p>同时，如果觉得自己做的镜像不错，那么可以分享到Docker Cloud，阿里云，腾讯云等，这里就不进行详细介绍了。</p><blockquote><p>Docker Cloud <a href="https://cloud.docker.com/" target="_blank" rel="noopener">https://cloud.docker.com/</a></p></blockquote><h2 id="Docker-入门推荐阅读"><a href="#Docker-入门推荐阅读" class="headerlink" title="Docker 入门推荐阅读"></a>Docker 入门推荐阅读</h2><blockquote><p>《Docker入门级简易手册》在线版：<a href="https://github.com/buxiaomo/MarkdownBooks" target="_blank" rel="noopener">https://github.com/buxiaomo/MarkdownBooks</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;关于安装Docker这里就不做介绍了，注意如果是个人使用安装ce版，免费的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;images – 镜像文件&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://hwolf.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Redis小结</title>
    <link href="http://hwolf.cn/2017/10/01/Redis%E5%B0%8F%E7%BB%93/"/>
    <id>http://hwolf.cn/2017/10/01/Redis小结/</id>
    <published>2017-10-01T11:16:48.000Z</published>
    <updated>2018-01-03T11:26:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li>稳定简单</li><li>丰富的数据结构</li><li>性能优秀</li><li>速度快</li><li>支持事务操作</li></ol><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ol><li>默认安装在 /usr/local/redis </li><li>后台启动 <code>redis-server &amp;</code></li><li>后台启动+日志 <code>nobup redis-server &amp;</code></li><li>关闭：<code>redis-cli shutdown</code></li><li>指定host&amp;port客户端 <code>redis-cli -h host -p port</code></li><li>默认16个库,可以通过修改配置文件,redis.conf,增加数据</li><li>删除所有数据<code>flushall</code></li><li>删除当前数据库数据<code>flushdb</code></li><li>获得所有配置数据<code>config get *</code></li><li>选择指定数据库<code>select db</code> </li><li>启动+配置 <code>redis-server redis.conf</code></li><li>启动 sentinel: <code>redis-sentinel redis-sentinel.conf</code></li><li>安全设置命令<code>AUTH</code></li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="String-最常用"><a href="#String-最常用" class="headerlink" title="String 最常用"></a>String 最常用</h3><ul><li>SET</li><li>GET</li><li>INCR 自增value 针对数字</li><li>DECR 自减</li><li>SETEX 设置键 + 过期时间 + 值</li><li>SETNX 设置不存在的key的value</li><li>GETSET 得到旧值，设置新值</li><li>APPEND 追加值</li><li>STRLEN 长度</li><li>INCRBY 指定增加步长</li><li>DECRBY 指定减步长</li><li>GETRANGE 获取指定长度的串</li><li>SETRANGE 修改之后的值</li><li>MSET 批量设置值</li><li>MGET 批量获取</li><li>MSETNX 批量设置都不存在的key值</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li>SADD</li><li>SMEMBERS</li><li>SISMEMBERS 判断是不是集合内的成员</li><li>SCARD 获取有几个成员</li><li>SREM 删除</li><li>SRANDMEMBER 随机返回一个</li><li>SPOP 删除一个元素</li><li>SMOVE 移动集合元素到另一个集合</li></ul><h3 id="zset-SortedSet"><a href="#zset-SortedSet" class="headerlink" title="zset(SortedSet)"></a>zset(SortedSet)</h3><p>根据设置的数值大小排序</p><ul><li>ZADD</li><li>ZREM</li><li>ZCAR</li><li>ZRANK 返回在ZSET中的位置</li><li>ZREVRANK</li><li>ZCOUNT</li><li>ZRANGE 从小到大 </li><li>ZREVRANGE 从大到小</li></ul><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>key:value</p><ul><li>HSET</li><li>HGET key key:value</li><li>HMSET</li><li>HMGET</li><li>HGETALL</li><li>HDEL</li><li>HKEYS</li><li>HVALS</li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li>LPUSH 左边插入</li><li>RPUSH 右边插入</li><li>LRANGE </li><li>LPOP</li><li>RPOP</li><li>LINDEX</li><li>LREM 删除指定个数</li><li>LTRIM 删除指定区域</li><li>LINSERT key BEFORE插入</li></ul><h2 id="命令总结-1-5"><a href="#命令总结-1-5" class="headerlink" title="命令总结 1+5"></a>命令总结 1+5</h2><ul><li>1种key(String的)，5种数据类型</li><li>所有命令都可以在Redis提供的文档下面查</li></ul><blockquote><p><a href="https://redis.io/commands" target="_blank" rel="noopener">https://redis.io/commands</a> </p></blockquote><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>KEYS *</li><li>EXISTS key</li><li>MOVE key db</li><li>TTL key</li><li>EXPIRE key seconds</li><li>TYPE key</li><li>DEL key</li><li>SET key value</li></ul><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><ol><li>就像驱动一样</li><li>订阅者重写 JedisPubSub 重写 onMessage</li></ol><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>三要素：producer,consumer,broker</p><p>生产者-&gt;MQ&lt;-消费者，都从消息队列取东西</p><p>优势：解耦，削峰</p><p>替代：ActiveMQ，RabbitMQ</p><ol><li>SUBSRIBE channel 先订阅</li><li>PUBLISH channel message 后发布</li></ol><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>Redis 的事务是不允许被打断的，一旦入队成功就是<strong>部分回滚</strong>。</p><ol><li>正常情况</li></ol><ul><li>开始事务:MULTI</li><li>事务书写</li><li>结束事务:EXEC</li></ul><ol><li>异常情况–语法错误</li></ol><ul><li>中间有任何异常事务都不能提交</li></ul><ol><li>例外情况</li></ol><ul><li>中间出错，但是还是成功进入队列</li></ul><ol><li>放弃情况</li></ol><ul><li>DISCARD</li></ul><ol><li>复杂情况–解决并发</li></ol><ul><li>悲观锁，乐观锁(基于版本号)，需要版本号一致，一旦修改版本号+1，比对版本号。</li><li>WATCH 机制，监控多个key，当数据在事务开始之前有变化那么当前事务就不能执行。</li></ul><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><ul><li>内存-&gt;磁盘</li><li>两种模式都开启默认加载AOF文件</li></ul><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><ul><li>指定时间间隔内，将内存快照写入磁盘，只需要配置文件redis.conf</li></ul><ol><li>save seconds changes</li><li>dbfilename</li></ol><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><ul><li><p>Append-only file 每次写操作时，写到AOF文件中，依旧是配置</p><ol><li>appendonly yes 是否开启</li><li>appendfilename 配置保存</li><li>appendfsync 配置策略：no 不主动同步，always总是，everysec 每秒一次</li><li>auto-aof-rewrite-percentage：超过指定大小重写aof文件</li><li>auto-aof-rewrite-min-size：允许重写的最小aof文件大小</li></ol></li></ul><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><ul><li>主从复制</li><li>高可用方案：Sentinel哨兵</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>主从复制 replication，配置主从关系（主从都要配置），master读写，slave只能读</li><li>查看主从关系 cli 中 info replication 查看是什么角色</li><li>注意：因为有多台redis-server，这时候启动客户端就要指定端口了。。。</li><li><strong>冷处理：</strong>当出故障的时候，我们需要将一个从提升为总用 slave no one，其他的也得配置从谁，因为挂掉了，信息都没了。</li><li><strong>热处理：</strong>当出故障的时候，自动提升的话需要利用 Sentinel 哨兵。配置 xxx/redis/sentinel.conf ，如果恢复，那么这个redis会自动恢复成<strong>从</strong>。</li></ul><h3 id="redis-conf"><a href="#redis-conf" class="headerlink" title="redis.conf"></a>redis.conf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 包含系统默认配置</span><br><span class="line">include /usr/local/redis/redis.conf</span><br><span class="line"># 后台启动</span><br><span class="line">daemonize yes </span><br><span class="line">port 6380</span><br><span class="line">pidfile /var/run/redis_6830.pid</span><br><span class="line">logfile 6380.log</span><br><span class="line">dbfilename dump6380.rdb</span><br><span class="line"># 如果是从数据库需要配置</span><br><span class="line">slaveof 127.0.0.1 6380</span><br></pre></td></tr></table></figure><h3 id="sentinel-conf"><a href="#sentinel-conf" class="headerlink" title="sentinel.conf"></a>sentinel.conf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># n 参数代表如果有多台监视，需要至少几台sentinel投票判定redis-server是否挂了</span><br><span class="line">sentinel monitor mymaster ip port n</span><br></pre></td></tr></table></figure><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>设置密码：配置redis.conf</li><li>认证：AUTH password123456</li><li>还没有使用的时候，就要<strong>改变命令</strong>名字</li><li>修改默认端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在配置中修改</span><br><span class="line">rename-command FLUSHALL 或者 rename-command CONFIG</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 设置你的密码</span><br><span class="line">requirepass password123456</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;特性&quot;&gt;&lt;a href=&quot;#特性&quot; class=&quot;headerlink&quot; title=&quot;特性&quot;&gt;&lt;/a&gt;特性&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;稳定简单&lt;/li&gt;
&lt;li&gt;丰富的数据结构&lt;/li&gt;
&lt;li&gt;性能优秀&lt;/li&gt;
&lt;li&gt;速度快&lt;/li&gt;
&lt;li&gt;支持事务操作
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://hwolf.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Spring Dispatcher</title>
    <link href="http://hwolf.cn/2017/09/25/Spring-Dispatcher/"/>
    <id>http://hwolf.cn/2017/09/25/Spring-Dispatcher/</id>
    <published>2017-09-25T11:52:29.000Z</published>
    <updated>2018-01-03T13:06:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Dispatcher"><a href="#Spring-Dispatcher" class="headerlink" title="Spring Dispatcher"></a>Spring Dispatcher</h1><h2 id="DispatcherServlet处理流程"><a href="#DispatcherServlet处理流程" class="headerlink" title="DispatcherServlet处理流程"></a>DispatcherServlet处理流程</h2><blockquote><p>Spring MVC框架，与其他很多web的MVC框架一样：请求驱动；所有设计都围绕着一个中央Servlet来展开，它负责把所有请求分发到控制器；DispatcherServlet应用的其实就是一个“前端控制器”的设计模式；</p></blockquote><p><img src="/image/DispatcherServlet.jpg" alt="请求流程"></p><p><strong>前端控制器模式</strong>是用来提供一个集中的<strong>请求处理</strong>机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做<strong>认证/授权/记录</strong>日志，或者<strong>跟踪/注册</strong>请求，然后把请求传给相应的处理程序。</p><h2 id="DispatcherServlet作用"><a href="#DispatcherServlet作用" class="headerlink" title="DispatcherServlet作用"></a>DispatcherServlet作用</h2><p>DispatcherServlet主要用作职责调度工作，本身主要用于控制流程，主要职责如下：</p><ol><li>文件上传解析，如果请求类型是multipart将通过MultipartResolver进行文件上传解析；</li><li>通过HandlerMapping，将请求映射到处理器（返回一个HandlerExecutionChain，它包括一个处理器、多个HandlerInterceptor拦截器）；</li><li>通过HandlerAdapter支持多种类型的处理器(HandlerExecutionChain中的处理器)；</li><li>通过ViewResolver解析逻辑视图名到具体视图实现；</li><li>本地化解析；</li><li>渲染具体的视图等；</li><li>如果执行过程中遇到异常将交给HandlerExceptionResolver来解析。</li></ol><p>同时，DispatcherServlet维护了一个列表，其中保存了其所依赖的所有bean的默认实现。这个列表保存在包org.springframework.web.servlet下的DispatcherServlet.properties文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"> // url请求和处理函数间的mapping关系</span><br><span class="line">    private List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class="line">    // 来实际调用处理函数</span><br><span class="line">    private List&lt;HandlerAdapter&gt; handlerAdapters;</span><br><span class="line">    // 异常处理</span><br><span class="line">    private List&lt;HandlerExceptionResolver&gt; handlerExceptionResolvers;</span><br><span class="line">...</span><br><span class="line">// 视图</span><br><span class="line">    private List&lt;ViewResolver&gt; viewResolvers;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="web-xml-配置"><a href="#web-xml-配置" class="headerlink" title="web.xml 配置"></a>web.xml 配置</h2><p>DispatcherServlet其实就是个Servlet（它继承自HttpServlet基类），同样也需要在你web应用的web.xml配置文件下声明。你需要在web.xml文件中把你希望DispatcherServlet处理的请求映射到对应的URL、处理类上去。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>example<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--xml文件内配置自己的Handler/Resolver--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Spring MVC会在你web应用的WEB-INF目录下查找一个名为[servlet-name]-servlet.xml的配置文件，并创建其中所定义的bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/spring-web.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Spring MVC中，每个DispatcherServlet都持有一个自己的上下文对象WebApplicationContext，它又继承了根（root）WebApplicationContext对象中已经定义的所有bean。这些继承的bean可以在具体的Servlet实例中被重载，在每个Servlet实例中你也可以定义其scope下的新bean。</p><p><img src="/image/Dispatcher-root.png" alt="Dispatcher-root"></p><h2 id="Dispatcher-拦截流程"><a href="#Dispatcher-拦截流程" class="headerlink" title="Dispatcher 拦截流程"></a>Dispatcher 拦截流程</h2><h3 id="流程简析"><a href="#流程简析" class="headerlink" title="流程简析"></a>流程简析</h3><p>Dispatcher 集成 FrameworkServlet</p><ol><li>doService 将上下文对象 WebApplicationContext/地区/主题 绑定到 request 中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 设置app上下文值</span></span><br><span class="line">request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.getWebApplicationContext());</span><br><span class="line"><span class="comment">// 地区解析器和地区绑定</span></span><br><span class="line">request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span><br><span class="line"><span class="comment">// 主题解析</span></span><br><span class="line">request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span><br><span class="line">request.setAttribute(THEME_SOURCE_ATTRIBUTE, <span class="keyword">this</span>.getThemeSource());</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol><li>multipart文件处理器</li></ol><p>之后，框架将判断该文件是不是multipart（分为多个部分连续上传）的。若是，则将该请求包装成一个MultipartHttpServletRequest对象，以便处理链中的其他组件对它做进一步的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.doDispatch(request, response);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是不是multipart，若是则交于其余组件处理</span></span><br><span class="line">            <span class="keyword">if</span>(!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted() &amp;&amp; attributesSnapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol><li>为该请求查找一个合适的处理器</li><li>如果处理器返回的是一个模型（model）</li><li>finally 方法，异步请求处理，判断异步请求是否在进行，保存快照时属性值与当前 reqeust 不同，则恢复。</li></ol><h3 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h3><p>可以定义一个或者多个HandlerMapping，将进入容器的web请求映射到合适的处理器方法上。允许在控制器上添加注解后，通常你就不必这么做了，因为RequestMappingHandlerMapping类会自动查找所有注解了@RequestMapping的@Controller控制器bean。</p><ol><li>interceptors</li><li>defaultHandler</li><li>order</li></ol><h3 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a>HandlerExceptionResolver</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 处理器异常解析器接口</span><br><span class="line"> * @param httpServletRequest</span><br><span class="line"> * @param httpServletResponse</span><br><span class="line"> * @param o</span><br><span class="line"> * @param e 异常捕获</span><br><span class="line"> * @return 返回指定处理页</span><br><span class="line"> */</span><br><span class="line">public interface HandlerExceptionResolver &#123;</span><br><span class="line">    ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>考虑到将DispatchServlet内的所有的源码全部解析一遍篇幅过长，也没有很大的意义，需要的才是重要的~~如果有需要了解更多的同学，请参考一下链接。</p><blockquote><ol><li><a href="https://linesh.gitbooks.io/spring-mvc-documentation-linesh-translation/content/publish/21-2/the-dispatcher-servlet.html" target="_blank" rel="noopener">Spring MVC 4.2.4.RELEASE 中文文档</a></li><li><a href="https://linesh.gitbooks.io/spring-mvc-documentation-linesh-translation/content/publish/21-2/1-special-bean-types-in-the-webapplicationcontext.html" target="_blank" rel="noopener">WebApplicationContext中特殊的bean类型</a></li><li><a href="http://www.runoob.com/design-pattern/front-controller-pattern.html" target="_blank" rel="noopener">前端控制器模式| 菜鸟教程</a></li><li><a href="http://jinnianshilongnian.iteye.com/blog/1602617" target="_blank" rel="noopener">DispatcherServlet详解 ——跟开涛学SpringMVC</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-Dispatcher&quot;&gt;&lt;a href=&quot;#Spring-Dispatcher&quot; class=&quot;headerlink&quot; title=&quot;Spring Dispatcher&quot;&gt;&lt;/a&gt;Spring Dispatcher&lt;/h1&gt;&lt;h2 id=&quot;Dispa
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://hwolf.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java线程常见问题</title>
    <link href="http://hwolf.cn/2017/08/01/Java%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://hwolf.cn/2017/08/01/Java线程常见问题/</id>
    <published>2017-08-01T13:20:45.000Z</published>
    <updated>2018-01-04T14:17:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客主要总结平时线程常见问题，不定期更新吧，答案是个人理解结合原博主们的答案（当然也有原搬的，2333），如果有什么不对的地方恳请指出~</p><ol><li>用Runnable还是Thread？<br>Java不支持多重继承，但是可以实现多个接口。Runnable是接口，所以一般用Runnable。</li><li>Thread 类中的start() 和 run() 方法有什么区别？<br>start()直接启动线程，run()线程并没有立即启动。</li><li>CyclicBarrier 和 CountDownLatch有什么不同？<br>CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier不同的是，CountdownLatch不能重新使用。</li><li>volatile 变量和 atomic 变量有什么不同？<ul><li>一旦对象加上volatile，此变量就变得“透明”，在多线程的情况下可以避免<strong>重排序</strong>，但<strong>不保证原子性</strong>；</li><li>atomic方法可以让这种操作具有原子性。</li></ul></li><li>什么是线程安全？Vector是一个线程安全类吗？<br>一、代码在单线程和多线程运行的结果是相同的，并且总是和预期一样的。二、Vector含有同步方法保证线程安全。</li><li>什么时候线程之间会存在竞态条件？<br>当两个线程竞争<strong>同一资源</strong>时，如果对资源的访问顺序敏感，就称存在竞态条件。</li><li>如何在两个线程间共享数据？<br>共享内存和消息队列。（暂时只想到这两个）</li><li>notify 和 notifyAll有什么区别？<br>字面区别，一个只唤醒<strong>一个</strong>等待线程，一个唤醒<strong>所有</strong>等待线程。</li><li>什么是ThreadLocal变量？<ul><li>ThreadLocal中文翻译为：线程局部变量。</li><li><strong>应用场景</strong>：当很多线程需要多次使用同一个对象，并且需要该对象具有相同初始化值的时候最适合使用ThreadLocal。</li><li>每个线程都有一个ThreadLocal就是每个线程都拥有了自己<strong>独立</strong>的一个变量，竞争条件被彻底消除了。</li></ul></li><li>什么是FutureTask？<ul><li>FutureTask类实现了RunnableFuture接口</li><li>它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当<strong>运算完成</strong>的时候结果才能取回，如果运算尚未完成get方法将会<strong>阻塞</strong>。</li></ul></li><li>什么是线程池？为什么要使用它？<ul><li>总想着自己创建线程是很麻烦的，也是很低效的，没有必要的话实在不用自己创建线程，倒不如一次创建一个指定大小的线程池，有需求的时候就去取~</li><li>常见的有：<strong>单线程池、缓存线程池</strong>等。</li></ul></li><li>有三个线程T1，T2，T3，怎么确保它们按顺序执行？<br>可以用线程类的<strong>join()</strong>方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。</li><li>synchronized 和 ReentrantLock 有什么不同？<br>synchronized是同步代码块的关键字，比较粗粒度，普适；ReentrantLock是重录锁，常和CountDownLatch结合使用，比较细粒度。</li><li>Thread类中的yield方法有什么作用？<br>yield方法可以<strong>暂停当前正在执行的线程对象</strong>，让其它有相同优先级的线程执行。</li><li>Java线程池中submit() 和 execute()方法有什么区别？<br>两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。</li><li>多线程中的忙循环是什么?<br>忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，<strong>避免重建缓存和减少等待重建的时间就可以使用它了</strong>。</li><li>fork join框架是什么？<br>它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了<strong>工作窃取算法</strong>，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。<blockquote><p>官方提供： <a href="http://www.oracle.com/technetwork/cn/articles/java/fork-join-422606-zhs.html" target="_blank" rel="noopener">分解和合并：Java 也擅长轻松的并行编程！</a></p></blockquote></li></ol><blockquote><p><a href="http://www.importnew.com/12773.html" target="_blank" rel="noopener">Java线程面试题 Top 50</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇博客主要总结平时线程常见问题，不定期更新吧，答案是个人理解结合原博主们的答案（当然也有原搬的，2333），如果有什么不对的地方恳请指出~&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用Runnable还是Thread？&lt;br&gt;Java不支持多重继承，但是可以实现多个接口。Runnable
      
    
    </summary>
    
    
      <category term="Java" scheme="http://hwolf.cn/tags/Java/"/>
    
      <category term="线程" scheme="http://hwolf.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java8小结</title>
    <link href="http://hwolf.cn/2017/07/30/Java8%E5%B0%8F%E7%BB%93/"/>
    <id>http://hwolf.cn/2017/07/30/Java8小结/</id>
    <published>2017-07-30T07:43:26.000Z</published>
    <updated>2018-01-09T04:15:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理，在别的语言中也就是箭头函数，先举个”Hello World”具体写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (参数列表)-&gt;函数式接口</span></span><br><span class="line"><span class="comment">// (arg1, arg2, ...) -&gt; &#123; body &#125;</span></span><br><span class="line">() -&gt; System.out.println(<span class="string">"Hello World"</span>);</span><br></pre></td></tr></table></figure><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>java.util.function是java 8 中一个新包，里面包含了超过40个预定义函数式接口方便你去书写 Lambda 表达式风格的代码。下面是一些常用的接口。</p><table><thead><tr><th style="text-align:center">函数式接口</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Function</td><td style="text-align:center">传递一个参数返回一个结果，这个结果的类型与R类型相同。</td></tr><tr><td style="text-align:center">BiFunction</td><td style="text-align:center">传递两个参数返回一个结果，这个结果的类型可以与参数的类型不相同。</td></tr><tr><td style="text-align:center">UnaryOperator</td><td style="text-align:center">它是Function 的子接口,返回结果类型与操作符的类型一样。</td></tr><tr><td style="text-align:center">BiOperator</td><td style="text-align:center">代表两个操作符的操作，它的返回结果类型必须与操作符相同。</td></tr><tr><td style="text-align:center">Predicate</td><td style="text-align:center">传递一个参数，基于参数的值返回boolean值。</td></tr><tr><td style="text-align:center">Supplier</td><td style="text-align:center">没有参数但返回一个值。</td></tr><tr><td style="text-align:center">Consumer</td><td style="text-align:center">传递一个参数但没有返回值。</td></tr></tbody></table><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>以下是我截取出了java.util.function包中的Function接口的源码，进行了注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// T是Target，传入参数类型；R是Return，返回的结果类型。</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface Function&lt;T, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 最基本，最常用</span><br><span class="line">     * 接收一个参数，再根据函数接口的方法体，返回指定类型数据</span><br><span class="line">     */</span><br><span class="line">    R apply(T t);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 适配器模式</span><br><span class="line">     * 接口的默认方法，当前接口V类型适配为传入接口V类型</span><br><span class="line">     * 要求before接口T与原接口R为同种类型，或者为继承关系关系</span><br><span class="line">     */</span><br><span class="line">    default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        return (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 1.先调用apply方法接收参数</span><br><span class="line">     * 2.根据andThen顺序将R传给的接口方法T，和流处理类似，具体见Demo</span><br><span class="line">     */</span><br><span class="line">    default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        return (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回与输入相同的函数</span><br><span class="line">     */</span><br><span class="line">    static &lt;T&gt; Function&lt;T, T&gt; identity() &#123;</span><br><span class="line">        return t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码是对Function的一个使用，列出了两种Lambda表达式的写法，同时，根据接口定义我们只能调用apply,compose,andThen方法，故不对identity进行详细讨论，在看之前首先得理解Function<t,r>的意义。</t,r></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void testFunction()&#123;</span><br><span class="line">    // 简单的,只有一行</span><br><span class="line">    Function&lt;Integer, String&gt; function1 = (x) -&gt; &quot;1234|&quot; + x;</span><br><span class="line"></span><br><span class="line">    // 标准的,有花括号, return, 分号.</span><br><span class="line">    Function&lt;String, Integer&gt; function2 = (x) -&gt; &#123;</span><br><span class="line">        return x.length();</span><br><span class="line">    &#125;;</span><br><span class="line">    // 第三个处理方法</span><br><span class="line">    Function&lt;Integer,String&gt;  function3 = (x)-&gt; &quot;the length is &quot; + x;</span><br><span class="line">    // 1.控制台输出：1234|6 </span><br><span class="line">    System.out.println(function1.apply(6));</span><br><span class="line">    // 2.控制台输出：the length is 6</span><br><span class="line">    System.out.println(function1</span><br><span class="line">    .andThen(function2)</span><br><span class="line">    .andThen(function3)</span><br><span class="line">    .apply(6));</span><br><span class="line">    </span><br><span class="line">    // 适配接口，返回HashMap</span><br><span class="line">    Function&lt;Integer,HashMap&lt;Integer,String&gt;&gt; function4 = (x)-&gt;&#123;</span><br><span class="line">      HashMap hashMap = new HashMap();</span><br><span class="line">      hashMap.put(x,x+&quot;号&quot;);</span><br><span class="line">      return hashMap;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 被适配接口，获取Map中的第一个值</span><br><span class="line">    Function&lt;Map&lt;Integer,String&gt;,String&gt; function5 = (x)-&gt; x.get(1);</span><br><span class="line">    // 可接受Integer类型的参数</span><br><span class="line">    // 控制台输出：1号</span><br><span class="line">    System.out.println(function5.compose(function4).apply(1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>compose<br>进行了简单的参数适配，让接口可以接收其他类型的参数，结果由被适配接口返回</li><li>andThen<br>最终结果由最后一个andThen返回<br><img src="/image/function-flow.png" alt="function-flow"></li></ul><h2 id="接口的默认方法和静态方法"><a href="#接口的默认方法和静态方法" class="headerlink" title="接口的默认方法和静态方法"></a>接口的默认方法和静态方法</h2><p>往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法，默认接口方法有点像抽象类中的非abstract方法，可以参考以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//TODO</span><br></pre></td></tr></table></figure><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><ol><li>构造器引用</li><li>静态方法引用</li><li>某个类的成员方法的引用</li><li>某个实例对象的成员方法的引用</li></ol><h2 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h2><p>使用@Repeatable注解定义重复注解</p><h2 id="注解功能的拓展"><a href="#注解功能的拓展" class="headerlink" title="注解功能的拓展"></a>注解功能的拓展</h2><p>注解几乎可以使用在任何元素上：局部变量、接口类型、超类和接口实现类，甚至可以用在函数的异常定义上，</p><h1 id="Java编译器的新特性"><a href="#Java编译器的新特性" class="headerlink" title="Java编译器的新特性"></a>Java编译器的新特性</h1><h2 id="获取参数名称"><a href="#获取参数名称" class="headerlink" title="获取参数名称"></a>获取参数名称</h2><p>在语言层面（使用反射API和Parameter.getName()方法）和字节码层面（使用新的javac编译器以及-parameters参数）提供支持。</p><p>如果你使用Maven进行项目管理，则可以在maven-compiler-plugin编译器的配置项中配置-parameters参数</p><h1 id="Java官方库的新特性"><a href="#Java官方库的新特性" class="headerlink" title="Java官方库的新特性"></a>Java官方库的新特性</h1><p>Java 8增加了很多新的工具类（date/time类），并扩展了现存的工具类，以支持现代的并发编程、函数式编程等。</p><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>Optional仅仅是一个容易：存放T类型的值或者null。</p><p>如果Optional实例持有一个非空值，则isPresent()方法返回true，否则返回false；orElseGet()方法，Optional实例持有null，则可以接受一个lambda表达式生成的默认值；map()方法可以将现有的Opetional实例的值转换成新的值；orElse()方法与orElseGet()方法类似，但是在持有null的时候返回传入的默认值。</p><h2 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h2><ul><li><p>中间操作：例如filter并不会执行实际的过滤操作，而是创建一个新的stream，并将原stream中符合条件的元素放入新创建的stream；</p></li><li><p>晚期操作：会遍历stream并得出结果或者附带结果；在执行晚期操作之后，stream处理线已经处理完毕，就不能使用了；</p></li><li><p>同时，支持并行处理是streams的一大优势。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO</span></span><br></pre></td></tr></table></figure><h2 id="Date-Time-API-JSR-310"><a href="#Date-Time-API-JSR-310" class="headerlink" title="Date/Time API(JSR 310)"></a>Date/Time API(JSR 310)</h2><p>Clock可以替代System.currentTimeMillis()和TimeZone.getDefault()<br>LocalDate和LocalTime<br>特定时区的data/time信息，则可以使用ZoneDateTime<br>Duration类，它持有的时间精确到秒和纳秒。这使得我们可以很容易得计算两个日期之间的不同</p><h2 id="并行数组"><a href="#并行数组" class="headerlink" title="并行数组"></a>并行数组</h2><h2 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h2><p>在java.util.concurrent.atomic包中也新增了不少工具类，列举如下：</p><ul><li>DoubleAccumulator</li><li>DoubleAdder</li><li>LongAccumulator</li><li>LongAdder</li></ul><p>java.util.concurrent.locks.StampedLock类，用于支持基于容量的锁——该锁有三个模型用于支持读写操作</p><h1 id="JVM特性"><a href="#JVM特性" class="headerlink" title="JVM特性"></a>JVM特性</h1><p>-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式&quot;&gt;&lt;/a&gt;Lambda表达式&lt;/h2&gt;&lt;p&gt;它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理，在别的语言中也就
      
    
    </summary>
    
    
      <category term="Java8" scheme="http://hwolf.cn/tags/Java8/"/>
    
  </entry>
  
</feed>
